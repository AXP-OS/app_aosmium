From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: fgei <fgei@gmail.com>
Date: Tue, 17 Feb 2026 06:45:45 +0000
Subject: [PATCH] service layer for downstream impl usage of shape detection

---
 .../android/downstream_impl/BUILD.gn          |  94 +++++
 .../android/downstream_impl/features.cc       |  72 ++++
 .../android/downstream_impl/features.h        |  18 +
 .../shape_detection/DownstreamImpls.java      | 106 ++++++
 .../DownstreamImplsFeatureList.java           |  57 +++
 .../DownstreamImplsFeatureMap.java            |  42 +++
 .../ZxingBarcodeDetectionImpl.java            | 343 ++++++++++++++++++
 7 files changed, 732 insertions(+)
 create mode 100644 services/shape_detection/android/downstream_impl/BUILD.gn
 create mode 100644 services/shape_detection/android/downstream_impl/features.cc
 create mode 100644 services/shape_detection/android/downstream_impl/features.h
 create mode 100644 services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImpls.java
 create mode 100644 services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureList.java
 create mode 100644 services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureMap.java
 create mode 100644 services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/ZxingBarcodeDetectionImpl.java

diff --git a/services/shape_detection/android/downstream_impl/BUILD.gn b/services/shape_detection/android/downstream_impl/BUILD.gn
new file mode 100644
index 0000000000000..17cb62c05b9ba
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/BUILD.gn
@@ -0,0 +1,94 @@
+import("//third_party/jni_zero/jni_zero.gni")
+
+source_set("features") {
+  sources = [
+    "features.cc",
+    "features.h",
+  ]
+
+  deps = [
+    ":feature_map_jni_headers",
+    "//base",
+  ]
+
+  public_deps = [
+  ]
+}
+
+java_cpp_features("java_features_srcjar") {
+  # External code should depend on ":features_java" instead.
+  visibility = [ ":*" ]
+  sources = [ "features.cc" ]
+  class_name = "org.chromium.shape_detection.DownstreamImplsFeatures"
+}
+
+android_library("features_java") {
+  srcjar_deps = [ ":java_features_srcjar" ]
+}
+
+java_cpp_enum("downstream_impl_mode_java_enums_srcjar") {
+  # External code should depend on ":downstream_impl_mode_enums_java" instead.
+  visibility = [ ":*" ]
+  sources = [
+    "features.cc",
+  ]
+}
+
+android_library("downstream_impl_mode_enums_java") {
+  deps = [
+    "//third_party/androidx:androidx_annotation_annotation_java",
+  ]
+  srcjar_deps = [ ":downstream_impl_mode_java_enums_srcjar" ]
+}
+
+android_library("feature_map_java") {
+  sources = [
+    "java/src/org/chromium/shape_detection/DownstreamImplsFeatureList.java",
+    "java/src/org/chromium/shape_detection/DownstreamImplsFeatureMap.java",
+  ]
+
+  deps = [
+    ":downstream_impl_mode_enums_java",
+    ":features_java",
+    "//base:base_java",
+    "//build/android:build_java",
+    "//third_party/jni_zero:jni_zero_java",
+  ]
+
+  srcjar_deps = [
+    ":feature_map_jni_headers",
+  ]
+}
+
+generate_jni("feature_map_jni_headers") {
+  visibility = [ ":*" ]
+  sources = [
+    "java/src/org/chromium/shape_detection/DownstreamImplsFeatureMap.java",
+  ]
+}
+
+android_library("downstream_impls_java") {
+  sources = [
+    "java/src/org/chromium/shape_detection/DownstreamImpls.java",
+    "java/src/org/chromium/shape_detection/ZxingBarcodeDetectionImpl.java",
+  ]
+
+  deps = [
+    ":downstream_impl_mode_enums_java",
+    ":feature_map_java",
+    "//base:base_java",
+    "//build/android:build_java",
+    "//mojo/public/java:base_java",
+    "//mojo/public/java:bindings_java",
+    "//mojo/public/java:system_java",
+    "//mojo/public/java/system:system_impl_java",
+    "//mojo/public/mojom/base:base_java",
+    "//services/shape_detection/public/mojom:mojom_java",
+    "//skia/public/mojom:mojom_java",
+    "//third_party/android_deps:chromium_play_services_availability_java",
+    "//third_party/zxing_core:zxing_core_java",
+    "//third_party/jni_zero:jni_zero_java",
+    "//ui/gfx/geometry/mojom:mojom_java",
+  ]
+}
+
diff --git a/services/shape_detection/android/downstream_impl/features.cc b/services/shape_detection/android/downstream_impl/features.cc
new file mode 100644
index 0000000000000..451eebe8868c4
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/features.cc
@@ -0,0 +1,72 @@
+#include "services/shape_detection/android/downstream_impl/features.h"
+
+#include "base/android/feature_map.h"
+#include "base/android/jni_android.h"
+#include "base/feature_list.h"
+#include "base/metrics/field_trial_params.h"
+#include "base/no_destructor.h"
+
+#include "services/shape_detection/android/downstream_impl/feature_map_jni_headers/DownstreamImplsFeatureMap_jni.h"
+
+namespace {
+
+// GENERATED_JAVA_ENUM_PACKAGE: org.chromium.shape_detection
+enum DownstreamImplUsageMode {
+    IF_NO_GMS,
+    IF_SYSTEM_APP,
+    ALWAYS,
+};
+
+// GENERATED_JAVA_ENUM_PACKAGE: org.chromium.shape_detection
+enum DownstreamImplDetectMode {
+    NONE,
+    SINGLE,
+    MULTIPLE,
+};
+
+const base::Feature* const kFeaturesExposedToJava[] = {
+    &kUseBarcodeDetectionImpl,
+    &kUseTextDetectionImpl,
+};
+
+// static
+base::android::FeatureMap* GetFeatureMap() {
+  static base::NoDestructor<base::android::FeatureMap> kFeatureMap(
+      kFeaturesExposedToJava);
+  return kFeatureMap.get();
+}
+
+inline constexpr const char* kUsageModeParam = "usage-mode";
+inline constexpr const char* kDetectModeParam = "detect-mode";
+
+} // namespace
+
+BASE_FEATURE(kUseBarcodeDetectionImpl, base::FEATURE_ENABLED_BY_DEFAULT);
+BASE_FEATURE_PARAM(int,
+                   kUseBarcodeDetectionImplUsageMode,
+                   &kUseBarcodeDetectionImpl,
+                   kUsageModeParam,
+                   DownstreamImplUsageMode::ALWAYS);
+BASE_FEATURE_PARAM(int,
+                   kUseBarcodeDetectionImplDetectMode,
+                   &kUseBarcodeDetectionImpl,
+                   kDetectModeParam,
+                   DownstreamImplDetectMode::MULTIPLE);
+
+BASE_FEATURE(kUseTextDetectionImpl, base::FEATURE_ENABLED_BY_DEFAULT);
+BASE_FEATURE_PARAM(int,
+                   kUseTextDetectionImplUsageMode,
+                   &kUseTextDetectionImpl,
+                   kUsageModeParam,
+                   DownstreamImplUsageMode::ALWAYS);
+BASE_FEATURE_PARAM(int,
+                   kUseTextDetectionImplDetectMode,
+                   &kUseTextDetectionImpl,
+                   kDetectModeParam,
+                   DownstreamImplDetectMode::NONE);
+
+static jlong JNI_DownstreamImplsFeatureMap_GetNativeMap(JNIEnv* env) {
+  return reinterpret_cast<jlong>(GetFeatureMap());
+}
+
+DEFINE_JNI(DownstreamImplsFeatureMap)
diff --git a/services/shape_detection/android/downstream_impl/features.h b/services/shape_detection/android/downstream_impl/features.h
new file mode 100644
index 0000000000000..8bd913c9cf133
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/features.h
@@ -0,0 +1,18 @@
+#ifndef SERVICES_SHAPE_DETECTION_ANDROID_DOWNSTREAM_IMPL_FEATURE_H_
+#define SERVICES_SHAPE_DETECTION_ANDROID_DOWNSTREAM_IMPL_FEATURE_H_
+
+#include <jni.h>
+
+#include "base/feature_list.h"
+#include "base/metrics/field_trial_params.h"
+
+BASE_DECLARE_FEATURE(kUseBarcodeDetectionImpl);
+BASE_DECLARE_FEATURE_PARAM(int, kUseBarcodeDetectionImplUsageMode);
+BASE_DECLARE_FEATURE_PARAM(int, kUseBarcodeDetectionImplDetectMode);
+
+BASE_DECLARE_FEATURE(kUseTextDetectionImpl);
+BASE_DECLARE_FEATURE_PARAM(int, kUseTextDetectionImplUsageMode);
+BASE_DECLARE_FEATURE_PARAM(int, kUseTextDetectionImplDetectMode);
+
+#endif // SERVICES_SHAPE_DETECTION_ANDROID_DOWNSTREAM_IMPL_FEATURE_H_
+
diff --git a/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImpls.java b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImpls.java
new file mode 100644
index 0000000000000..b4a6abc166184
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImpls.java
@@ -0,0 +1,106 @@
+package org.chromium.shape_detection;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+
+import org.chromium.base.ContextUtils;
+import org.chromium.base.Log;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.build.annotations.NonNull;
+import org.chromium.gms.ChromiumPlayServicesAvailability;
+import org.chromium.shape_detection.mojom.BarcodeDetection;
+import org.chromium.shape_detection.mojom.BarcodeDetectorOptions;
+import org.chromium.shape_detection.mojom.TextDetection;
+
+import static org.chromium.shape_detection.DownstreamImplsFeatureList.*;
+
+final class DownstreamImpls {
+
+    static final String TAG = "DownstreamImpls";
+
+    static boolean shouldUseBarcodeDetectionImpl() {
+        if (!sUseBarcodeDetectionImpl.isEnabled()) {
+            return false;
+        }
+
+        Context appCtx = ContextUtils.getApplicationContext();
+        int downstreamImplUsageMode = sUseBarcodeDetectionImplUsageMode.getValue();
+        return switch (downstreamImplUsageMode) {
+            case DownstreamImplUsageMode.IF_NO_GMS -> {
+                yield !ChromiumPlayServicesAvailability.isGooglePlayServicesAvailable(appCtx);
+            }
+
+            case DownstreamImplUsageMode.IF_SYSTEM_APP -> {
+                ApplicationInfo appInfo = appCtx.getApplicationInfo();
+                if (appInfo != null) {
+                    if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                        Log.i(TAG, "Enabling downstream barcode detection implementation "
+                                + "reason: always enabled for sytstem apps");
+                        yield true;
+                    }
+                }
+                yield !ChromiumPlayServicesAvailability.isGooglePlayServicesAvailable(appCtx);
+            }
+
+            default -> {
+                Log.i(TAG, "Enabling downstream barcode detection implementation "
+                        + "reason: always enabled");
+                yield true;
+            }
+        };
+    }
+
+    static boolean shouldUseTextDetectionImpl() {
+        if (!sUseTextDetectionImpl.isEnabled()) {
+            return false;
+        }
+
+        Context appCtx = ContextUtils.getApplicationContext();
+        int downstreamImplUsageMode = sUseBarcodeDetectionImplUsageMode.getValue();
+        return switch (downstreamImplUsageMode) {
+            case DownstreamImplUsageMode.IF_NO_GMS -> {
+                yield !ChromiumPlayServicesAvailability.isGooglePlayServicesAvailable(appCtx);
+            }
+
+            case DownstreamImplUsageMode.IF_SYSTEM_APP -> {
+                ApplicationInfo appInfo = appCtx.getApplicationInfo();
+                if (appInfo != null) {
+                    if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                        Log.i(TAG, "Enabling downstream text detection implementation "
+                                + "reason: always enabled for user apps");
+                        yield true;
+                    }
+                }
+                yield !ChromiumPlayServicesAvailability.isGooglePlayServicesAvailable(appCtx);
+            }
+
+            default -> {
+                Log.i(TAG, "Enabling downstream text detection implementation "
+                        + "reason: always enabled");
+                yield true;
+            }
+        };
+    }
+
+    @Nullable
+    static BarcodeDetection getBarcodeDetection(@NonNull BarcodeDetectorOptions options) {
+        @DownstreamImplDetectMode
+        int detectMode = sUseBarcodeDetectionImplDetectMode.getValue();
+        if (detectMode == DownstreamImplDetectMode.NONE) {
+            return null;
+        }
+
+        return new ZxingBarcodeDetectionImpl(options, detectMode);
+    }
+
+    @Nullable
+    static TextDetection getTextDetection() {
+        @DownstreamImplDetectMode
+        int detectMode = sUseTextDetectionImplDetectMode.getValue();
+        if (detectMode == DownstreamImplDetectMode.NONE) {
+            return null;
+        }
+
+        return null;
+    }
+}
diff --git a/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureList.java b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureList.java
new file mode 100644
index 0000000000000..4f369e93a45ef
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureList.java
@@ -0,0 +1,57 @@
+package org.chromium.shape_detection;
+
+import org.chromium.base.MutableFlagWithSafeDefault;
+import org.chromium.base.MutableIntParamWithSafeDefault;
+
+import org.chromium.build.annotations.NonNull;
+import org.chromium.build.annotations.NullMarked;
+
+@NullMarked
+final class DownstreamImplsFeatureList {
+
+    private static final String TAG = "DownstreamImplsFeatureList";
+
+    private static final String USAGE_MODE_PARAM = "usage-mode";
+    private static final String DETECT_MODE_PARAM = "usage-mode";
+
+    private DownstreamImplsFeatureList() {
+    }
+
+    @NonNull
+    static final MutableFlagWithSafeDefault sUseBarcodeDetectionImpl =
+            new MutableFlagWithSafeDefault(
+                    DownstreamImplsFeatureMap.getInstance(),
+                    DownstreamImplsFeatures.USE_BARCODE_DETECTION_IMPL,
+                    true);
+
+    @NonNull
+    static final MutableIntParamWithSafeDefault sUseBarcodeDetectionImplUsageMode =
+            sUseBarcodeDetectionImpl.newIntParam(
+                    USAGE_MODE_PARAM,
+                    DownstreamImplUsageMode.ALWAYS);
+
+    @NonNull
+    static final MutableIntParamWithSafeDefault sUseBarcodeDetectionImplDetectMode =
+            sUseBarcodeDetectionImpl.newIntParam(
+                    DETECT_MODE_PARAM,
+                    DownstreamImplDetectMode.MULTIPLE);
+
+    @NonNull
+    static final MutableFlagWithSafeDefault sUseTextDetectionImpl =
+            new MutableFlagWithSafeDefault(
+                    DownstreamImplsFeatureMap.getInstance(),
+                    DownstreamImplsFeatures.USE_TEXT_DETECTION_IMPL,
+                    true);
+
+    @NonNull
+    static final MutableIntParamWithSafeDefault sUseTextDetectionImplUsageMode =
+            sUseTextDetectionImpl.newIntParam(
+                    USAGE_MODE_PARAM,
+                    DownstreamImplUsageMode.ALWAYS);
+
+    @NonNull
+    static final MutableIntParamWithSafeDefault sUseTextDetectionImplDetectMode =
+            sUseTextDetectionImpl.newIntParam(
+                    DETECT_MODE_PARAM,
+                    DownstreamImplDetectMode.NONE);
+}
diff --git a/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureMap.java b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureMap.java
new file mode 100644
index 0000000000000..7f94b3f481954
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/DownstreamImplsFeatureMap.java
@@ -0,0 +1,42 @@
+package org.chromium.shape_detection;
+
+import org.jni_zero.JNINamespace;
+import org.jni_zero.NativeMethods;
+
+import org.chromium.base.FeatureMap;
+import org.chromium.base.Log;
+import org.chromium.build.annotations.NonNull;
+import org.chromium.build.annotations.NullMarked;
+
+@NullMarked
+public final class DownstreamImplsFeatureMap extends FeatureMap {
+
+    private static final String TAG = "DownstreamImplsFeatureMap";
+
+    @NonNull
+    private static final DownstreamImplsFeatureMap sInstance =
+            new DownstreamImplsFeatureMap();
+
+    private DownstreamImplsFeatureMap() {
+    }
+
+    @NonNull
+    static DownstreamImplsFeatureMap getInstance() {
+        return sInstance;
+    }
+
+    static boolean isEnabled(String featureName) {
+        return getInstance().isEnabledInNative(featureName);
+    }
+
+    @Override
+    protected long getNativeMap() {
+        return DownstreamImplsFeatureMapJni.get().getNativeMap();
+    }
+
+    @NativeMethods
+    public interface Natives {
+        long getNativeMap();
+    }
+}
+
diff --git a/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/ZxingBarcodeDetectionImpl.java b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/ZxingBarcodeDetectionImpl.java
new file mode 100644
index 0000000000000..9844ac1bcf841
--- /dev/null
+++ b/services/shape_detection/android/downstream_impl/java/src/org/chromium/shape_detection/ZxingBarcodeDetectionImpl.java
@@ -0,0 +1,343 @@
+package org.chromium.shape_detection;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.util.ArrayMap;
+
+import com.google.zxing.BarcodeFormat;
+import com.google.zxing.BinaryBitmap;
+import com.google.zxing.DecodeHintType;
+import com.google.zxing.LuminanceSource;
+import com.google.zxing.MultiFormatReader;
+import com.google.zxing.NotFoundException;
+import com.google.zxing.RGBLuminanceSource;
+import com.google.zxing.Result;
+import com.google.zxing.ResultPoint;
+import com.google.zxing.common.HybridBinarizer;
+import com.google.zxing.multi.ByQuadrantReader;
+import com.google.zxing.multi.GenericMultipleBarcodeReader;
+
+import org.chromium.base.Log;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.build.annotations.NonNull;
+import org.chromium.gfx.mojom.PointF;
+import org.chromium.gfx.mojom.RectF;
+import org.chromium.gms.ChromiumPlayServicesAvailability;
+import org.chromium.mojo.system.MojoException;
+import org.chromium.mojo_base.BigBufferUtil;
+import org.chromium.shape_detection.mojom.BarcodeDetection;
+import org.chromium.shape_detection.mojom.BarcodeDetectionResult;
+import org.chromium.shape_detection.mojom.BarcodeDetectorOptions;
+import org.chromium.skia.mojom.BitmapN32;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+
+final class ZxingBarcodeDetectionImpl implements BarcodeDetection {
+
+    private static final String TAG = "ZxingBarcodeDetectionImpl";
+
+    private static final Result[] EMPTY_ZXING_RESULT_ARRAY = new Result[0];
+    private static final BarcodeDetectionResult[] EMPTY_BARCODE_DETECTION_RESULT_ARRAY =
+            new BarcodeDetectionResult[0];
+
+    private final MultiFormatReader mMultiFormatReader = new MultiFormatReader();
+    private final ByQuadrantReader mByQuadrantReader =
+            new ByQuadrantReader(mMultiFormatReader);
+    private final GenericMultipleBarcodeReader mMultiBarcodeReader =
+            new GenericMultipleBarcodeReader(mByQuadrantReader);
+    private final @DownstreamImplDetectMode int mDetectMode;
+
+    private final ArrayList<BarcodeFormat> mZxingFormats = new ArrayList<>();
+
+    public ZxingBarcodeDetectionImpl(
+            @NonNull BarcodeDetectorOptions options,
+            @DownstreamImplDetectMode int detectMode) {
+        mDetectMode = detectMode;
+        if (options.formats == null || options.formats.length <= 0) {
+            Log.w(TAG, "no format found, no options to be added");
+            return;
+        }
+
+        for (int i = 0; i < options.formats.length; ++i) {
+            int optionsFormat = options.formats[i];
+            BarcodeFormat zxingFormat = switch (optionsFormat) {
+                case org.chromium.shape_detection.mojom.BarcodeFormat.AZTEC:
+                    yield BarcodeFormat.AZTEC;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.CODABAR:
+                    yield BarcodeFormat.CODABAR;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.CODE_39:
+                    yield BarcodeFormat.CODE_39;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.CODE_93:
+                    yield BarcodeFormat.CODE_93;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.CODE_128:
+                    yield BarcodeFormat.CODE_128;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.DATA_MATRIX:
+                    yield BarcodeFormat.DATA_MATRIX;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.EAN_8:
+                    yield BarcodeFormat.EAN_8;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.EAN_13:
+                    yield BarcodeFormat.EAN_13;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.ITF:
+                    yield BarcodeFormat.ITF;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.PDF417:
+                    yield BarcodeFormat.PDF_417;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.QR_CODE:
+                    yield BarcodeFormat.QR_CODE;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.UPC_A:
+                    yield BarcodeFormat.UPC_A;
+                case org.chromium.shape_detection.mojom.BarcodeFormat.UPC_E:
+                    yield BarcodeFormat.UPC_E;
+                default:
+                    yield null;
+            };
+
+            if (zxingFormat == null) {
+                continue;
+            }
+
+            mZxingFormats.add(zxingFormat);
+        }
+
+        mMultiFormatReader.setHints(getBaselineHints());
+    }
+
+    /**
+     * @See {@link BitmapUtils#convertToBitmap(BitmapN32)}.
+     * Method referenced above is copied for logging purposes,
+     * and to avoid circular dependency, along with dependency with GmsCore.
+     */
+    @Override
+    public void detect(BitmapN32 bitmapData, Detect_Response callback) {
+        var pixelData = bitmapData.pixelData;
+        if (pixelData == null) {
+            Log.e(TAG, "No pixelData found from bitmap data");
+            callback.call(new BarcodeDetectionResult[0]);
+            return;
+        }
+
+        int width = bitmapData.imageInfo.width;
+        int height = bitmapData.imageInfo.height;
+
+        final long numPixels = (long) width * height;
+        Bitmap bitmap = null;
+        // TODO(mcasas): https://crbug.com/670028 homogeneize overflow checking.
+        if (width <= 0 || height <= 0 || numPixels > (Long.MAX_VALUE / 4)) {
+            Log.e(TAG, "invalid value for dimensions of bitmap data");
+            callback.call(new BarcodeDetectionResult[0]);
+            return;
+        }
+
+        try (BigBufferUtil.Mapping mapping = BigBufferUtil.map(pixelData)) {
+            ByteBuffer imageBuffer = mapping.getBuffer();
+            if (imageBuffer.capacity() <= 0) {
+                Log.e(TAG, "Insufficient capacity for bitmap conversion");
+                callback.call(new BarcodeDetectionResult[0]);
+                return;
+            }
+
+            bitmap = Bitmap.createBitmap(width, height,
+                    Bitmap.Config.ARGB_8888);
+            bitmap.copyPixelsFromBuffer(imageBuffer);
+        }
+
+        if (bitmap == null) {
+            Log.e(TAG, "No bitmap was converted from bitmap data");
+            callback.call(new BarcodeDetectionResult[0]);
+            return;
+        }
+
+        int[] pixels = new int[width * height];
+        bitmap.getPixels(pixels, 0, width, 0, 0, width, height);
+        RGBLuminanceSource rgbLuminanceSource =
+                new RGBLuminanceSource(width, height, pixels);
+        Result[] zxingResults = EMPTY_ZXING_RESULT_ARRAY;
+
+        if (mDetectMode == DownstreamImplDetectMode.MULTIPLE) {
+            try {
+                var bBitmap = getBinaryBitmap(rgbLuminanceSource);
+                ArrayMap<DecodeHintType, Object> hints = getBaselineHints();
+                zxingResults = mMultiBarcodeReader.decodeMultiple(bBitmap, hints);
+                if (zxingResults.length > 0) {
+                    detectInner(zxingResults, callback);
+                    return;
+                }
+            } catch (NotFoundException e) {
+            }
+
+            try {
+                var bBitmap = getBinaryBitmap(rgbLuminanceSource);
+                ArrayMap<DecodeHintType, Object> hints = getBaselineHints();
+                hints.put(DecodeHintType.TRY_HARDER, true);
+                zxingResults = mMultiBarcodeReader.decodeMultiple(bBitmap, hints);
+                if (zxingResults.length > 0) {
+                    detectInner(zxingResults, callback);
+                    return;
+                }
+            } catch (NotFoundException e) {
+            }
+
+            try {
+                var bBitmap = getBinaryBitmap(rgbLuminanceSource.invert());
+                ArrayMap<DecodeHintType, Object> hints = getBaselineHints();
+                hints.put(DecodeHintType.POSSIBLE_FORMATS, mZxingFormats);
+                zxingResults = mMultiBarcodeReader.decodeMultiple(bBitmap, hints);
+                if (zxingResults.length > 0) {
+                    detectInner(zxingResults, callback);
+                    return;
+                }
+            } catch (NotFoundException e) {
+            }
+
+            try {
+                var bBitmap = getBinaryBitmap(rgbLuminanceSource.invert());
+                ArrayMap<DecodeHintType, Object> hints = getBaselineHints();
+                hints.put(DecodeHintType.TRY_HARDER, true);
+                zxingResults = mMultiBarcodeReader.decodeMultiple(bBitmap, hints);
+                if (zxingResults.length > 0) {
+                    detectInner(zxingResults, callback);
+                    return;
+                }
+            } catch (NotFoundException e) {
+            }
+        }
+
+        try {
+            var bBitmap = getBinaryBitmap(rgbLuminanceSource);
+            Result zxingResult = mMultiFormatReader.decodeWithState(bBitmap);
+            zxingResults = new Result[1];
+            zxingResults[0] = zxingResult;
+            if (zxingResults.length > 0) {
+                detectInner(zxingResults, callback);
+                return;
+            }
+        } catch (NotFoundException e) {
+        }
+
+        Log.e(TAG, "Unable to decode barcodes from the bitmap data");
+        callback.call(new BarcodeDetectionResult[0]);
+        return;
+    }
+
+    private void detectInner(Result[] zxingResults, Detect_Response callback) {
+        ArrayList<BarcodeDetectionResult> barcodeResults = new ArrayList<>();
+        for (int i = 0; i < zxingResults.length; ++i) {
+            Result zxingResult = zxingResults[i];
+            @org.chromium.shape_detection.mojom.BarcodeFormat.EnumType
+            int mojomFormat = switch (zxingResult.getBarcodeFormat()) {
+                case AZTEC:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.AZTEC;
+                case CODABAR:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.CODABAR;
+                case CODE_39:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.CODE_39;
+                case CODE_93:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.CODE_93;
+                case CODE_128:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.CODE_128;
+                case DATA_MATRIX:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.DATA_MATRIX;
+                case EAN_8:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.EAN_8;
+                case EAN_13:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.EAN_13;
+                case ITF:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.ITF;
+                case PDF_417:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.PDF417;
+                case QR_CODE:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.QR_CODE;
+                case UPC_A:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.UPC_A;
+                case UPC_E:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.UPC_E;
+                default:
+                    yield org.chromium.shape_detection.mojom.BarcodeFormat.UNKNOWN;
+            };
+
+            if (mojomFormat == org.chromium.shape_detection.mojom.BarcodeFormat.UNKNOWN) {
+                continue;
+            }
+
+            BarcodeDetectionResult barcodeRes = new BarcodeDetectionResult();
+            barcodeRes.format = mojomFormat;
+            barcodeRes.rawValue = zxingResult.getText();
+            ResultPoint minXResPoint = null;
+            ResultPoint minYResPoint = null;
+            ResultPoint maxXResPoint = null;
+            ResultPoint maxYResPoint = null;
+            for (ResultPoint point: zxingResult.getResultPoints()) {
+                if (minXResPoint == null
+                        || Float.compare(minXResPoint.getX(), point.getX()) > 0) {
+                    minXResPoint = point;
+                }
+                if (minYResPoint == null
+                        || Float.compare(minYResPoint.getY(), point.getY()) > 0) {
+                    minYResPoint = point;
+                }
+                if (maxXResPoint == null
+                        || Float.compare(point.getX(), maxXResPoint.getX()) > 0) {
+                    maxXResPoint = point;
+                }
+                if (maxYResPoint == null
+                        || Float.compare(point.getY(), maxYResPoint.getY()) > 0) {
+                    maxYResPoint = point;
+                }
+            }
+            if (minXResPoint == null || minYResPoint == null
+                    || maxXResPoint == null || maxYResPoint == null) {
+                continue;
+            }
+            barcodeRes.boundingBox = new RectF();
+            barcodeRes.boundingBox.height =
+                    maxYResPoint.getY() - minYResPoint.getY();
+            barcodeRes.boundingBox.width =
+                    maxXResPoint.getX() - minXResPoint.getX();
+            barcodeRes.boundingBox.x = minXResPoint.getX();
+            barcodeRes.boundingBox.y = maxYResPoint.getY();
+            PointF[] mojomCornerPoints = new PointF[4];
+            mojomCornerPoints[0] = new PointF();
+            mojomCornerPoints[0].x = minXResPoint.getX();
+            mojomCornerPoints[0].y = minXResPoint.getY();
+            mojomCornerPoints[1] = new PointF();
+            mojomCornerPoints[1].x = maxXResPoint.getX();
+            mojomCornerPoints[1].y = minXResPoint.getY();
+            mojomCornerPoints[2] = new PointF();
+            mojomCornerPoints[2].x = maxXResPoint.getX();
+            mojomCornerPoints[2].y = maxYResPoint.getY();
+            mojomCornerPoints[3] = new PointF();
+            mojomCornerPoints[3].x = minXResPoint.getX();
+            mojomCornerPoints[3].y = maxYResPoint.getY();
+            barcodeRes.cornerPoints = mojomCornerPoints;
+            barcodeResults.add(barcodeRes);
+        }
+
+        callback.call(barcodeResults.toArray(EMPTY_BARCODE_DETECTION_RESULT_ARRAY));
+    }
+
+    @Override
+    public void close() {
+        // Can do nothing, based on existing implementations on zxing
+        // among supported mojom formats, where RSS reader is not included.
+        // Still call reset() in case of future implementation changes.
+        mMultiFormatReader.reset();
+    }
+
+    @Override
+    public void onConnectionError(MojoException e) {
+        close();
+    }
+
+    @NonNull
+    private BinaryBitmap getBinaryBitmap(@NonNull LuminanceSource luminanceSource) {
+        var binarizer = new HybridBinarizer(luminanceSource);
+        return new BinaryBitmap(binarizer);
+    }
+
+    @NonNull
+    private ArrayMap<DecodeHintType, Object> getBaselineHints() {
+        ArrayMap<DecodeHintType, Object> hints = new ArrayMap<>();
+        hints.put(DecodeHintType.POSSIBLE_FORMATS, mZxingFormats);
+        return hints;
+    }
+}
